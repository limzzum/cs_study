## equals를 재정의하려거든 hashCode도 재정의하라

해시 코드에도 일반 규약 3가지가 있다.
```
- equals 비교에 사용되는 정보가 변경되지 않았다면, hashCode 메서드는 항상 같은 값을 반환해야 한다.
- equals가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 같은 값을 반환해야 한다.
- equals가 두 객체를 다르게 판단하여도 두 객채의 hashCode는 같을 수 있다.
(하지만 다른 값을 반환해야 해시테이블의 성능이 좋아질 것이다)
```
이러한 hashCode의 일반 규약을 지키기 위해서는 equals 메서드와 hashCode는 같이 재정의 되어야 한다.

이런 원칙을 제대로 지키지 않으면 HashMap이나 HashSet 같은 컬렉션의 원소로 사용될 때 문제를 일으킬 수 있다.
equals를 재정의하여 논리적 동치를 비교하도록 클래스를 만들어도 HashMap의 원소로 사용될 땐
해시코드가 다르면 동치성 비교를 시도조차 하지 않는다. 

해시코드를 작성하려면 equals 비교에 사용되는 필드(핵심 필드)로 계산해 주면 된다.
equals 비교에 사용되지 않는 필드는 반드시 제외해야 한다.

속도는 조금 느려지지만 Objects 에서 제공하는 hash 메서드도 있다.
```
@Override public int hashCode(){
    return Objects.hash(필드1, 필드 2 ..);
}
```
이렇게 사용할 수 있다.

또, 클래스가 불변이고 해시코드를 계산하는 비용이 크다면 캐싱하는 방식으로 제공할 수도 있을 것이다.
하지만 성능을 높인답시고 해시코드 계산에 핵심 필드를 빼는 일은 없도록 하자.