## equals는 일반 규약을 지켜 재정의하라

모든 객체의 공통 메서드는 추상화하여 계층 구조로 설계한다.
Object 객체는 구체 클래스이지만 상속해서 사용하도록 설계되었다.
그렇기 때문에 final이 아닌 메서드는 재정의를 염두에 두고 설계된 것이고, 
이를 재정의 할 때 지켜야 할 일반 규약이 명화히 정의되어 있다.

그 중 equals 메서드에 대해 알아 본다.
equals 메서드는 잘못 재정의 할 경우 예기치 못한 오류를 일으키기 때문에 웬만하면 재정의 하지 않는 것이 좋다.
재정의 하지 않아도 되는 경우는
```
- 각 인스턴스가 본질적으로 고유하고, 인스턴스의 논리적 동치성을 검사할 일이 없다.
- 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.
- 클래스가 private이거나 package-private이어서 equals 메서드를 호출할 일이 없다.
이런 경우에는 그냥 재정의를 하지 않으면 된다.
```

그런데 기본 equals 메서드는 객체가 물리적으로 동일한지를 확인하는데,
논리적 동치성을 검사할 필요가 있을 수 있다.
=> 주로 값 객체는 논리적 동치성을 비교하기를 원한다.

예를 들어 Integer(1)를 통해 두 개의 객체를 만들면, 만들 때마다 새로운 인스턴스를 반환할 것이다.
그리고 이 두 인스턴스는 물리적으로 다르지만 우리는 1의 숫자를 비교하여 같다고 판단하길 원한다.
또 Map이나 Set을 활용할 때에도 물리적 동치성을 검사한다면 모두 다른 값으로 인식이 될 것이다.

eqauls 메서드를 재정의 할 때 지켜야 하는 일반 규약은 다음과 같다.

```
1. 반사성
    - 객체는 자기 자신과 같아야 한다 => x.equals(x)는 true
    - 객체를 자신과 비교할 때 true인 것은 일부러 false를 반환하게 하지 않는 이상 만족하지 않기가 힘들다.
  
2. 대칭성
    - a.equals(b)가 true이면 b.equals(a)도 true => 서로 같아야 한다.
3. 추이성
    - a와 b가 같고, b가 c와 같으면 a도 c와 같아야 한다.
4. 일관성
    - equals의 판단에 신뢰할 수 없는 자원이 끼어들게 해서는 안 된다.
    - 한 번 같거나 다르면 끝까지 같거나 달라야 한다.
    => 가변 객체라면 객체가 수정되지 않는 한, 불변 객체라면 끝까지 같은 답을 내야한다.
     
5. null-아님
    - 모든 객체가 null 과 같지 않아야 한다.
    => 객체를 null과 비교했을 때 true를 반환하면 안된다.
```    
그럼 이 일반규약들을 어기게 되는 상황들을 예로 살펴보자.

우선 동치성은 String 을 예로 들 수 있다.
String의 equals는 논리적 동치성을 검사해준다.
그런데 대소문자까지 구분없이 판단해주는 새로운 클래스를 만들었다.
그리고 equals를 재정의 해주었고 비교 대상이 String인 경우도 호환할 수 있도록 정의해주었다.
문자열 "abc"인 String 객체 a와 문자열 "ABc"인 새로운 클래스의 객체 b가 있을 때,
a.equals(b) 는 false , b.equals(a)는 false가 되어 대칭성을 위배한다.
이런 경우 String과의 호환성을 포기해야 한다.

두 번째로 추이성을 살펴본다.
추이성은 구체클래스의 상속관계에서 지키기 어려워진다. (추상 클래스는 인스턴스화를 못하기 때문에 문제가 없다)

```
public class Point{
    private final int x;
    private final int y;
    
    @Override public boolean equals(Object o){
        if(!(o instanceof Point))
            return;
        Point p = (Point) o;
        return p.x == x && p.y == y;
    }
   
}
```
예시를 위해 나머지 코드는 전부 생략하고 class의 구성만 보여주겠다.
이렇게 x, y 필드를 가지고 있는 Point 클래스가 있고, equals메서드는 이 두 가지의 필드를
비교하여 같은지 판단해주고 있다.

그리고 이 Point 를 상속한 ColorPoint를 살펴보자.

```
public class ColorPoint extends Point {
    private final Color color;
}
```

ColorPoint 클래스에는 색상 필드가 하나 추가되었다.
여기서 equals를 재정의하지 않으면 그대로 상속받아 color는 무시하고 x,y값만 비교하여 판단한다.

그럼 ColorPoint 클래스끼리만 비교하도록 수정해볼까?
```
@Override public boolean equals(Object o){
    if(!(o instanceof ColorPoint))
        return false;
    return super.equals(o) && ((ColorPoint) o).color == color;
}
```
그렇다면 Point 객체와의 비교에서 Point 객체에서는 x,y가 같다면 true를 반환,
ColorPoint 객체는 무조건 false를 반환하여 대칭성을 위배한다.

그럼 Point 객체와 비교할 때만 color를 무시하도록 해보자.
```
if(!(o instanceof ColorPoint))
    return o.equals(this);
```
=> x,y가 같고 color만 다른 두 ColorPoint 객체는 x,y가 같은 Point 객체와 동일하다고 판단되면서
   두 ColorPoint는 다르다고 판단되기 때문에 추이성이 깨진다.

결론적으로 구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는다. 
그럼 그냥 구체 클래스끼리만 비교하게 하면 안되나요?
=> 리스코프 치환 원칙을 위배한다.
Point의 하위 클래스는 정의상 여전히 Point이다. 어디서든 Point로써 활용될 수 있어야 한다.

그렇기 때문에 구체 클래스를 확장하여 사용하는 것보다 나중에 나올 컴포지션(아이템 18)을 활용할 수 있다.

다음으로 일관성이다.
일관성을 지키기 위해 equals의 판단에 신뢰할 수 없는 자원이 끼워들면 안된다고 하였다.
예를 들어 java.net.URL의 equals는 주어진 URL과 매핑된 호스트의 IP주소를 이용해 비교하는데,
IP주소로 바꾸기위해 네트워크를 통하는게 결과가 항상 같다고 보장할 수 없다. 
-> 동적 IP 할당이나 로드밸런싱으로 인해 IP주소가 달라질 수 있고, 네트워크의 오류 결과를 받지 못할 수 있다.
그렇기 때문에 equals는 항상 메모리에 존재하는 결정적 계산만 수행해야 한다.

마지막으로 null-아님은 객체를 null과 같다고 반환하면 안된다는 것인데
x.equals(null) 이 true를 반환하지 않더라도 NullPointerException 오류를 낼 수 있기 때문에
타입 검사를 해주어야 한다.
앞서 구현한 코드처럼 instanceof 연산자를 사용한다면 묵시적 null 검사가 되어 해결된다.


이렇게 주의사항을 유의하여 재정의 할 수 있도록 하자.
값을 비교할 땐 기본 타입 필드는 == 연산자로, 참조 타입필드는 각각의 equals 메서드로 비교하면 된다.
기본 타입 중 float 와 double은 특수한 부동소수 값을 다뤄야 하기 때문에 Float.compare, Double.compare로 비교한다.
또 비교하기가 복잡한 필드를 가지고 있다면 이를 표준형으로 저장해두고 비교할 수 있다.

어떤 필드를 먼저 비교하는지도 성능에 영향을 주기 때문에 다를 가능성이 더 큰 것,
혹은 비교 비용이 싼 것을 먼저 비교 하도록 하자.

마지막으로 추가 주의사항이 있다.
equals를 재정의할 땐 hashCode도 반드시 재정의하자.(아이템 11)
Object 외의 타입을 매개변수로 받는 equals 메서드는 선언하지 말자.
=> 그 외의 타입은 재정의가 아닌 다중정의가 된다. 이는 의도와 다르게 동작하게 만들 수 있으므로 
   @Override 애너테이션을 사용하여 실수를 예방하자.
