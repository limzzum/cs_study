## 변경 가능성을 최소화하라

불변 클래스란 그 인스턴스의 내부 값을 수정할 수 없는 클래스이다.
가변 클래스보다 설계, 구현, 사용이 쉽고 오류가 생길 여지도 적어 훨씬 안전하다.

클래스를 불변으로 만들기 위한 다섯가지 규칙이 있다.

```
- 객체의 상태를 변경하는 메서드를 제공하지 않는다.
- 클래스를 확장할 수 없도록 한다.
- 모든 필드를 final로 선언한다.
- 모든 필드를 private으로 선언한다.
- 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
```

불변 객체의 예시를 살펴보면
```
pulic final class Complex {
    private final double re;
    private final double im;
    
    public Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }
    
    public Coomplex plus(Complex c) {
        return new Complex(re + c.re, im + c.im);
    }
}
```

plus 메서드를 살펴보면 피연산자에 함수를 적용해 그 결과를 반환하지만, 피연산자 자체는 그대로이고
새로운 객체를 반환하고 있다. 이런 패턴을 함수형 프로그래밍 이라고 한다.
또, 메서드 이름도 add와 같은 동사가 아닌 전치사인 plus를 사용해 객체의 값을 변경하지 않는 것을 강조한다.

불변클래스의 장점을 살펴보자.
```
- 불변은 스레드 안전하게 만드는 가장 쉬운 방법이다.
  동기화가 필요없고 안심하고 공유가능하다.

- 불변 클래스는 자주 사용되는 인스턴스를 캐싱을 통해 중복 생성하지 않도록 해주면 좋다.
  => 이때 정적 팩터리를 사용할 수 있다. 메모리 사용량이 줄고 가비지 컬렉션 비용이 줄어든다.

- 방어적 복사가 불필요하다.
- 객체끼리 내부 데이터 공유 가능하다.
    - BigInteger에서는 부호와 크기를 따로 표현하는데, 크기가 같고 부호만 반대인 새로운 BigInteger를
      생성하는 메서드인 negate 메서드를 호출할 때 크기에 해당하는 int 배열을 그냥 원본 인스턴스와 공유하도록 한다.

- 그 자체로 실패 원자성을 제공한다.
    - 예외가 발생한 후에도 그 객체는 여전히  유효한 상태이다.
    
- 맵이나 집합의 원소로 쓰기에 안성맞춤이다.
    - 안에 담긴 값이 변하게 된다면 불변식이 허물어지는데 그런 걱정이 없다.
```

물론 단점도 있다.
값이 다르면 반드시 독립된 개체를 만들어야 하는데 매번 새로운 객체를 생성한다는 것은 비용이 많이 든다.
모든 값이 다 같은데 하나만 다르다면 그것을 위해 또 새로운 객체를 만들어야 한다.
이러한 문제를 해결하기 위해 다단계 연산이라는 것이 있다.

이러한 다단계 연산을 도와주는 가변 동반 클래스가 있는데 대표적인 예로 String의 StringBuilder가 있다.
String은 불변으로, 한 번 생성된 String 객체는 변경될 수 없다.
그렇기 때문에 문자열을 자주 변경하게 되면 항상 새로운 객체를 생성해야 하기 때문에 비용이 많이든다.

StringBuilder는 가변 클래스로, 문자열을 변경할 수 있는 기능을 제공한다.
StringBuilder 객체는 내부적으로 문자열을 저장하는 버퍼를 가지고 있는데, 이 버퍼에 문자열을 추가, 삭제, 수정하는 등의 작업을 할 수 있다.
StringBuilder를 사용하면 문자열을 조작할 때 매번 새로운 객체를 생성하지 않아도 되므로, 메모리 사용을 줄이고 성능을 높여준다.

불변 객체는 사실상 final이어야 한다.
그렇지 않으면 이 객체를 확장하여 재정의가 가능해질 수 있기 떄문에 불변을 보장하지 못한다.
BigInteger에서는 이러한 개념이 있기 전 만들어져 메서드들이 재정의 가능하게 설계되었다.
그러니 BigInteger나 BigDecimal을 인수로 받을 때에는 이것이 불변이어야 하는 값이라면 신뢰할 수 없는
하위 클래스의 인스턴스는 아니인지 확인을 해야한다. 
인수가 가변일수도 있기 때문에 이런 경우에는 방어적 복사를 사용해야 한다.

```
public static BigInteger safeInstance(BigInteger val){
    return val.getClass() == BigInteger.class ?
        val : new BigInteger(val.toByteArray());
}
```

불변식을 만들기 위한 조건 중 모든 필드를 final로 선언해야 하는 것이 있었지만, 캐싱을 위해
일부 필드는 final이 아니게 만들기도 한다.
불변 클래스의 주된 원칙은 클래스가 객체가 생성된 후에는 그 상태가 변하지 않아야 한다는 것인데
어떤 불변 클래스는 계산 비용이 큰 값을 나중에 계산하여(지연 초기화) final이 아닌 필드에 캐시해 놓는다.
그래서 똑같은 값을 다시 요청하면 캐시해둔 값을 반환하여 계산 비용을 절감한다.

이렇게 불변으로 만들 수 없는 클래스라도 변경 가능한 부분은 최대한 줄이도록 하자.
객체가 가질 수 있는 상태의 수를 줄이면 그 객체는 예측하기 쉬워지고 오류가 생길 가능성이 줄어든다.
불변 클래스는 성능이 떨어질 수 있다는 단점은 있지만 객체 상태를 초기화하여 재활용 하는 것은 복잡성이 증가하는데
성능 이점은 거의 없다.  

**결론: 클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.**