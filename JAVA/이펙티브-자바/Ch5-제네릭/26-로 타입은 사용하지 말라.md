## 로 타입은 사용하지 말라

클래스와 인터페이스 선언에 타입 매개변수가 쓰이면, 이를 '제네릭 클래스' 혹은 '제네릭 인터페애스' 라 한다.
List 인터페이스는 타입 매개변수를 받는 제네릭 인터페이스다.
```
List<Integer> 와 같이 타입 매개변수를 쓴다.
원소의 타입이 Integer(실제 타입 매개변수)인 리스트를 뜻하는 매개변수화 타입이다.
List의 완전한 이름은 List<E> 라고 쓸 수 있다.
```
이러한 제네릭 클래스, 제네릭 인터페이스를 통틀어 제네릭 타입이라고 한다.

여기서 로(Raw)타입은 List이다. 제네릭 타입에서 타입 매개변수를 사용하지 않은 것이다.
```
private final Collection stamps = ...;
```
이렇게 타입을 지정하지 않고 사용하는 것으로, 제네릭을 지원하기 전에는 이렇게 사용했었다.
그렇기 때문에 이러한 제네릭 지원 전 코드와 호환되도록 로타입을 허용하고, 제네릭 구현에서는 소거 방식을 사용한다.
제네릭은 런타임 시에는 타입 정보가 소거되고 동작한다.
이는 컴파일 시에 타입 체크를 모두 진행하고 형변환 코드를 추가하기 때문에 문제 없이 동작한다.

이러한 로타입의 문제점은 컴파일러에서는 어떤 타입인지 모른다는 것이다.
이 컬렉션에는 원래 의도했던 Stamp를 넣는 대신 다른 객체를 넣어도 오류없이 컴파일 될 것이다.
그리고 런타임시에 값을 꺼내 Stamp로 형변환을 시도하면 그때 오류가 발생할 것이다.

그런데 이 코드를
```
private final Collection<Stamp> stamps = ...;
```
이렇게 매개변수화 타입으로 사용하게 되면 컴파일러가 Stamp가 아닌 다른 객체를 넣으려고 하면
컴파일 시점에 오류를 내 알려준다.
컴파일러는 컬렉션에서 원소를 꺼내는 모든 곳에 보이지 않는 형변환을 추가하여 절대 실패하지 않음을 보장한다.


로타입을 사용하지 않으려면 어떤 방법을 사용할 수 있을까?
```
- 비한정적 와일드 카드인 '?'를 사용할 수 있다.
    - Set<?> 이런식으로 사용할 수 있고, 모든 타입을 허용한다는 뜻이다.
    - 로 타입과 달리 타입 안전함을 보장한다. => 어떻게? 비한정적 와일드 카드는 모든 타입을 허용하지만 추가나 수정같은
      작업을 수행하지 못한다.(null추가는 가능) 메서드 내에서는 어떤 타입인지 알지 못하기 때문이다. 
      그렇기 때문에 주로 읽기 작업만 수행하는 경우 와일드 카드를 사용할 수 있다. 
    - 와일드 카드는 혼자 쓰기 보단 주로 <? extends T> 와 같이 쓰인다.
        - 타입 T나 타입 T의 하위 타입들을 허용한다는 뜻이다.
        
- 값의 추가나 수정도 가능한 제네릭 메서드 T를 사용할 수 있다.
    - 제네릭 타입 매개변수인 T를 사용하면 다양한 타입에 대한 일반적인 코드를 작성할 수 있다.
    
    public class Box<T> {
    private T content;

    public void setContents(T content) {
        this.content = content;
    }

    public T getContents() {
        return content;
    }
    
    이런식으로 어떤 타입이든지 만들 수 있다.
    Box<Integer> intBox = new Box<>(); => Integer 타입의 Box를 만들 수 있다.
}

    
```

여기에도 로 타입을 써야하는 몇 가지 경우도 있다.
```
    - 클래스 리터럴에는 매개변수화 타입을 사용하지 않는다.
        - List.class, int.class 허용 O. List<String>.class 허용 X 
    - instanceof 연산자
        - 런타임에는 제네릭 타입 정보가 지워지므로 매개변수화 타입에는 적용할 수 없다.
        - 로 타입이든 비한정적 와일드카드 타입이든 instanceof 메서드는 똑같이 동작한다.
            => 코드를 지저분하게 만들 필요 없이 로타입을 사용하자.
            => if( o instanceof Set){...} 
```

