## 제네릭과 가변인수를 함께 쓸 때는 신중하라

가변인수 메서드를 호출하면 가변인수를 담기 위한 배열이 자동으로 하나 만들어진다.
그런데 가변인수가 제네릭이나 메개변수화 타입이라면?
=> 컴파일 경고가 발생한다.

매개변수화 타입의 변수가 타입이 다른 객체를 참조하면 힙 오염이 발생한다.
그럼 컴파일러가 자동 생성한 형변환에 실패할 수 있는데, 제네릭 타입 시스템이 약속한 타입 안전성이 보장되지
못할 수 있는 것이다.

```
    static void dangerous(List<String>... stringLists) {
        List<Integer> intList = List.of(42);
        Object[] objects = stringLists;
        objects[0] = intList;
        String s = stringLists[0].get(0);
    }
```
이 예시에서는 다른 곳에서 제네릭타입의 stringLists를 참조하면서 힙 오염이 발생했다.
마지막 줄에서는 자동 형변환이 일어나며 오류를 던지게 되고 타입 안정성이 깨진것을 확인할 수 있다.

제네릭 배열을 직접 선언하는 것은 허용하지 않는다.
그런데 왜 매개변수로 제네릭을 받을 수 있도록 허용하는 걸까? ==> Object[] objects = stringLists로 제네릭 배열이 생성된다.
제네릭이나 매개변수화 타입의 매개변수를 받는 것이 실무에서 매우 유용하기 때문이다.
그래서 언어 설계자가 이러한 모순을 허용한 것이다.

자바 라이브러리에서도 Arrays.asList(T... a) 같은 메서드들을 찾아볼 수 있다.
그리고 이러한 메서드에는 @SafeVarargs 애너테이션을 달아 클라이언트 측에서 발생하는 경고를 숨길 수 있다.
=> 메서드 작성자가 메서드의 타입 안전함을 보장하는 장치다.

타입 안전함을 보장하려면
```
    - 가변 인수 메서드를 호출할 때 생성되는 varargs 매개변수를 담는 제네릭 배열에 아무것도 저장하지 않는다.
    - 만들어진 배열의 참조를 밖으로 노출시키지 않는다.
    - 제네릭 varargs 매개변수 배열에 다른 메서드가 접근하도록 허용하지 않는다.
        - 만약 제네릭 매개변수를를 전달하는 다른 메서드를 또 호출한다면,
          해당 메서드에 넘길 인스턴스를 담을 varargs 매개변수 배열을 생성하게 된다.
          이때 배열의 타입은 Object[]인데, 이게 그대로 현재메서드의 반환값으로도 적용이 되어 전달되므로 
          ClassCastException이 발생할 수 있다.
```

이러한 규칙을 지키기 어렵다면 이미 @SafeVarargs가 보장된 List를 배열대신 사용하도록 하자.
