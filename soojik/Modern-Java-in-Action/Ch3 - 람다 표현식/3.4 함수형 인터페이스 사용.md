# 3.4 ν•¨μν• μΈν„°νμ΄μ¤ μ‚¬μ©

**ν•¨μ λ””μ¤ν¬λ¦½ν„°**: ν•¨μν• μΈν„°νμ΄μ¤μ μ¶”μƒ λ©”μ„λ“ μ‹κ·Έλ‹μ²  
λ‹¤μ–‘ν• ν‘ν„μ‹μ„ μ‚¬μ©ν•λ ¤λ©΄ κ³µν†µμ ν•¨μ λ””μ¤ν¬λ¦½ν„°λ¥Ό κΈ°μ ν•λ” ν•¨μν• μΈν„°νμ΄μ¤ μ§‘ν•©μ΄ ν•„μ”ν•λ‹¤.  
μ΄λ―Έ ν„μ¬μ μλ°” APIλ” `Comparable`, `Runnable`, `Callable` κ³Ό κ°™μ€ λ‹¤μ–‘ν• ν•¨μν• μΈν„°νμ΄μ¤λ¥Ό ν¬ν•¨ν•κ³  μλ‹¤.  
μλ°” 8 λΌμ΄λΈλ¬λ¦¬ μ„¤κ³„μλ“¤μ€ java.util.function ν¨ν‚¤μ§€λ΅ μ—¬λ¬ ν•¨μν• μΈν„°νμ΄μ¤λ¥Ό λ μ κ³µν•κ³  μλ‹¤.  
e.g.) Predicate, Consumer, Function ...

## 3.4.1 Predicate
`java.util.function.Predicate<T>`  

**μ¶”μƒ λ©”μ„λ“**: `test()`  
**μ‹κ·Έλ‹μ²**: `T` -> `boolean`μ„ λ°ν™ν•λ‹¤.

λ‹¤μκ³Ό κ°™μ΄ μ‚¬μ©ν•  μ μλ‹¤.  
```java
@FunctionalInterface
public interface Predicate<T> {
  boolean test(T t);
}

public List<T> filter(List<T> list, Predicate<T> p) {
  List<T> results = new ArrayList();
  
  for (T t : list) {
    if (p.test(t)) result.add(t);
  }
  
  return result;
}

Predicate<String> nonEmptyStringPredicate = (String s) -> !s.isEmpty();
List<String> nonEmpty = filter(listOfStrings, nonEmptyStringPredicate);
```

## 3.4.2 Consumer
`java.util.function.Consumer<T>`  

**μ¶”μƒ λ©”μ„λ“**: `accept()`  
**μ‹κ·Έλ‹μ²**: `T` -> `void`

λ‹¤μκ³Ό κ°™μ΄ λ°°μ—΄μ„ μνν•λ©° λ¨λ“  Integerλ¥Ό μ¶λ ¥ν•λ„λ΅ ν•  μ μλ‹¤.
```java
@FunctionalInterface
public interface Consumer<T> {
  void accept(T t);
}

public void forEach(List<T> list, Consumer<T> c) {
  for (T t : list) c.accept(t);
}
forEach(
        Arrays.asList(1, 2, 3, 4, 5),
        (Integer i) -> System.out.println(i) /* Consumerμ acceptλ¥Ό κµ¬ν„ν• λλ‹¤ */
        
)
```

## 3.4.3 Function
`java.util.function.Function<T, R>`

**μ¶”μƒ λ©”μ„λ“**: `apply()`
**μ‹κ·Έλ‹μ²**: `T` -> `R`

λ‹¤μκ³Ό κ°™μ΄ μ£Όμ–΄μ§„ λ¬Έμμ—΄ λ°°μ—΄μ„ μνν•λ©° κΈΈμ΄ λ°°μ—΄μ„ λ°ν™ν•λ„λ΅ ν•  μ μλ‹¤.  
```java
@FunctionalInterface
public interface Function<T, R> {
  R apply(T t);
}

public List<R> map(List<T> list, Function<T, R> f) {
  List<R> result = new ArrayList();
  
  for (T t : list) result.add(f.apply(t));
  
  return result;
}

List<Integer> result = map(
        Arrays.asList("Predicate", "Consumer", "Function"),
        (String s) -> s.length() /* Functionμ applyλ¥Ό κµ¬ν„ν• λλ‹¤ */
)
```
---
### κΈ°λ³Έν• νΉν™”
μλ°”μ ν•μ‹μ€ μ°Έμ΅°ν•(reference type; Byte, Integer, List)κ³Ό κΈ°λ³Έν•(primitive type; int, double, char)μΌλ΅ κµ¬λ¶„ν•  μ μλ‹¤.  
μ λ„¤λ¦­ λ‚΄λ¶€ κµ¬ν„ μƒ, νλΌλ―Έν„° <T> μ—λ” μ°Έμ΅°ν•λ§ μ‚¬μ©ν•  μ μλ‹¤.  
λ”°λΌμ„ μλ°”λ” κΈ°λ³Έν•κ³Ό μ°Έμ΅°ν• μ‚¬μ΄λ¥Ό μ¤κ° μ μλ”(λ³€ν™ν•  μ μλ”) κΈ°λ¥μ„ μ κ³µν•λ‹¤.  
- λ°•μ‹±(boxing): κΈ°λ³Έν• -> μ°Έμ΅°ν•
- μ–Έλ°•μ‹±(unboxing): μ°Έμ΅°ν• -> κΈ°λ³Έν•

μ„μ™€ κ°™μ€ λ°•μ‹± μ‘μ—…μ΄ μλ™μΌλ΅ μ΄λ£¨μ–΄μ§€λ„λ΅ μ¤ν† λ°•μ‹±μ΄λΌλ” κΈ°λ¥λ„ μ κ³µν•λ‹¤.  

```java
List<Integer> list = new ArrayList();

/* κΈ°λ³Έν•(int)μ„ μ°Έμ΅°ν•(Integer)μ„ λ‹΄λ” listμ— λ”°λ΅ λ°•μ‹±ν•μ§€ μ•μ•„λ„ μλ™μΌλ΅ μ²λ¦¬λλ‹¤. */
for (int i=0;i<10;i++) list.add(i);
```

ν•μ§€λ§ λ°•μ‹±ν• κ°’μ€ κΈ°λ³Έν•μ„ κ°μ‹Έλ” λνΌμ΄κ³ , ν™μ— μ €μ¥λκΈ°μ— λ³€ν™ κ³Όμ •μ— λΉ„μ©μ΄ μ†λ¨λλ‹¤.  
λ”°λΌμ„ λ°•μ‹±ν• κ°’μ€ λ©”λ¨λ¦¬λ¥Ό λ” μ†λΉ„ν•΄ κΈ°λ³Έν•μ„ κ°€μ Έμ¬ λ•λ„ λ©”λ¨λ¦¬λ¥Ό νƒμƒ‰ν•λ” κ³Όμ •μ΄ ν•„μ”ν•λ‹¤.  

μλ°” 8μ—μ„λ” κΈ°λ³Έν•μ„ μ…μ¶λ ¥μΌλ΅ μ‚¬μ©ν•λ” μƒν™©μ—μ„ μ¤ν† λ°•μ‹±μ„ ν”Όν•  μ μλ„λ΅ ν•¨μν• μΈν„°νμ΄μ¤λ¥Ό μ κ³µν•λ‹¤.  

```java
public interface IntPredicate {
  boolean test(int t);
}

IntPredicate evenNums = (int i) -> i % 2 == 0;
/* (int i) -> (int t) κΈ°λ³Έν•μ΄κΈ° λ•λ¬Έμ— λ°•μ‹± κ³Όμ •μ΄ μ—†λ‹¤. */
evenNums.test(1000);

Predicate<Integer> oddNums = (Integer i) -> i % 2 == 1;
/* (Integer i) -> (T t) μ°Έμ΅°ν•μ΄κΈ°μ— λλ‹¤μ‹μ—μ„ κΈ°λ³Έν•μ„ μ£Όλ”λΌλ„ λ°•μ‹±λμ–΄ λ„μ–΄κ°„λ‹¤. */
oddNums.test(1000);
```

μ΄μ²λΌ νΉμ • ν•μ‹μ„ μ…λ ¥μΌλ΅ λ°›λ” ν•¨μν• μΈν„°νμ΄μ¤μ μ΄λ¦„ μ•μ—λ” `DoublePredicate`, `IntPredicate` μ™€ κ°™μ΄ ν•μ‹λ…μ΄ λ¶™λ”λ‹¤.  
Function μΈν„°νμ΄μ¤λ„ `ToIntFunction<T>`, `IntToDoubleFunction` μ²λΌ λ‹¤μ–‘ν• μ¶λ ¥ ν•μ‹ νλΌλ―Έν„°λ¥Ό μ κ³µν•λ‹¤.  

> ν€΄μ¦: ν•¨μν• μΈν„°νμ΄μ¤  
> λ‹¤μκ³Ό κ°™μ€ ν•¨μν• λ””μ¤ν¬λ¦½ν„°κ°€ μμ„ λ• μ–΄λ–¤ ν•¨μν• μΈν„°νμ΄μ¤λ¥Ό μ‚¬μ©ν•  μ μλ”κ°€?  
> λν• μ΄λ“¤ ν•¨μ μΈν„°νμ΄μ¤μ— μ‚¬μ©ν•  μ μλ” μ ν¨ν• λλ‹¤ ν‘ν„μ‹μ„ μ μ‹ν•΄λΌ.  
> 1. T -> R
> 2. (int, int) -> int
> 3. T -> void
> 4. () -> T
> 5. (T, U) -> R

> μ •λ‹µ
> 1. `Function<T, R>` / `(String s) -> s.length()`
> 2. `IntBinaryOperator` / `(int i1, int i2) -> i1 + i2` 
> 3. `Consumer<T>` / `(Integer i) -> System.out.println(i)`
> 4. `Callable`, `Supplier<T>` / `() -> new String()`
> 5. `BiFunction<T, U, R>` / `(Apple a1, Apple a2) -> a1.getWeight() + a2.getWeight()`  

> ### π’΅ μμ™Έ, λλ‹¤, ν•¨μν• μΈν„°νμ΄μ¤μ κ΄€κ³„  
> ν•¨μν• μΈν„°νμ΄μ¤λ” ν™•μΈλ μμ™Έ(checked exception)λ¥Ό λμ§€λ”(throws) λ™μ‘μ„ ν—μ©λμ§€ μ•λ”λ‹¤.  
> μ¦‰, μμ™Έλ¥Ό λμ§€λ” λλ‹¤ ν‘ν„μ‹μ„ λ§λ“¤λ ¤λ©΄ checked exceptionμ„ μ„ μ–Έν•λ” ν•¨μν• μΈν„°νμ΄μ¤λ¥Ό μ§μ ‘ μ •μν•κ±°λ‚ λλ‹¤λ¥Ό try/catch λΈ”λ΅μΌλ΅ κ°μ‹Έμ•Όν•λ‹¤.  
> μμ „ BufferedReaderProcessor λ¥Ό μ‚΄ν΄λ³΄λ©΄,
>```java
> @FunctionalInterface
> public interface BufferedReaderProcessor {
>     String process(BufferedReader br) throws IOException;
> }
> BufferedReaderProcessor P = (BufferedReader br) -> br.readLine();
> ```
> μ΄ μƒν™©μ—μ„ Function<T, R> ν•μ‹μ ν•¨μν• μΈν„°νμ΄μ¤λ¥Ό κΈ°λ€ν•λ” APIλ¥Ό μ‚¬μ©ν•κ³  μκ³ , μ§μ ‘ ν•¨μν• μΈν„°νμ΄μ¤λ¥Ό λ§λ“¤κΈ°λ” μ–΄λ ¤μ΄ μƒν™©μ΄λ‹¤.  
> κ·Έλ ‡λ‹¤λ©΄ λ‹¤μ μμ μ²λΌ λ…μ‹μ μΌλ΅ `checked exception`μ„ μ΅μ„ μ μλ‹¤.  
> ```java
> Function<BufferedReader, String> f = (BufferedReader b) -> {}
> try {
>   return b.readLine();
> }
> catch(IOException e) {
>   throw new RuntimeException(e);
> }
> ```