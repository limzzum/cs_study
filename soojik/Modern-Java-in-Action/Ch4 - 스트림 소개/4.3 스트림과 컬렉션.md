# 4.3 스트림과 컬렉션

컬렉션
- DVD가 전체 자료구조가 저장하는 것처럼 모든 요소를 가져와야한다.
- 현재 자료구조가 포함하는 모든 값을 메모리에 저장하는 자료구조로, 모든 요소는 컬렉션에 추가하기 전에 계산되어야함
- 적극적 생산(팔기도 전에 창고를 가득 채우는 생산자 중심)
  끝도 없는 소수를 출력한다면 컬렉션은 모든 소수를 포함하려 할 것이므로 무한 루프를 돌며 새로운 소수를 찾을 것이다.  
  결국 소비자는 영원히 결과를 못 본다.

스트림
- 영상 스트리밍처럼 원하는, 사용자가 시청하는 부분의 몇 프레임을 미리 내려 받는다.
- 이론적으로 요청할 때만 요소를 계산하는 고정된 자료구조로, 사용자가 요청하는 값만 스트림에서 추출
- 무제한 소수를 출력한다면 간단하게(6장에서 예제) 생성할 수 있고, 바로 사용자만 요청하는 값을 추출할 수 있다.  

## 4.3.1 딱 한 번만 탐색할 수 있다.
탐색된 스트림의 요소는 소비되기에, 딱 한번만 탐색이 가능하다.    
다시 탐색하려면 초기 데이터 소스에서 새로운 스트림을 만들어야 하는데, 소스가 I/O 채널이라면 새로운 스트림을 만들 수 없다.  

> 스트림과 컬렉션의 철학적 접근
> 스트림은 시간적으로 흩어진 값의 집합으로 간주할 수 있고,  
> 컬렉션은 특정 시간에 모든 것이 존재하는 공간(메모리)에 흩어진 값으로 비유할 수 있다.

## 4.3.2 외부 반복과 내부 반복
외부 반복: 컬렉션 인터페이스 사용하려면 사용자가 직접 요소를 반복해야하는 것처럼, `for-each`  
내부 반복: 반복을 알아서 처리하고 결과 스트림값을 어딘가에 저장  

외부 반복은 아래와 같이 명시적으로 컬렉션 항목을 하나씩 가져와 처리한다.
```java
List<String> names = new ArrayList();
for (Dish d : menu) names.add(d.getName());
```

내부 반복은 스트림 내에서 우리가 알 필요 없이 데이터를 하나씩 탐색해준다.
```java
List<String> names = menu.stream().map(Dish::getName).collect(toList());
```

내부 반복이 더 좋은 이유
1. 하나의 데이터를 탐색하며 다른 데이터도 함께 탐색 가능(병렬처리 지원)
2. 최적화된 순서로 처리 가능

다만, 이런 내부 반복을 사용하려면 filter, map 과 같이 반복을 숨겨주는 연산 리스트가 미리 정의되어있어야 한다.